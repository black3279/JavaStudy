# Java_Study
## 1. Java 란 ?
자바란 오라클에서 개발한 객체지향 프로그래밍 언어이다. 1996년 발표된 자바는 1990년대 말 인터넷 활성화 시점과 맞물려 웹 환경에 가장 적합한 언어로 인식되면서 인기를 얻게 되었다.

## 2. Java 언어의 특징
- 운영체제 독립적인 언어이다 "Write Once, Run anywhere !"
- 객체지향 언어이다 "OOP is A P.I.E!" Abstraction, Polymorphism, Inheritance, Encapsulation
- 상대적으로 배우기 쉬운 언어이다. (포인터와 메모리 관리)
- 다양한 API 제공
- JVM : 소스코드를 컴파일 해서 만든 실행 파일을 해석하는 방법이 다른 OS 에 종속적이지 않도록, 가상머신 JVM 내에서 실행하여 플랫폼 독립적으로 프로그래밍 할 수 있다.
소스파일 - javac (컴파일) - byte 코드 -> JVM -> OS -> 정상동작
- GC : 메모리를 관리하는 백그라운드 프로그램

## 3. 자료형
- Primitive Type : (1) boolean, byte (2) char, short (4) int, float (8) long, double
- 정수형 리터럴 : 0b (2진수) , 0 (8진수), 0x (16진수)
- 문자열 포맷 : %b (논리값), %d (정수), %o (8진수), %x/%X (16진수), %f (실수), %e/%E (지수), %c (문자), %s (문자열), %n (개행문자)

## 4. 객체지향 프로그래밍
객체지향의 큰 특징 중 하나로 모듈화를 들 수 있다. 모듈화란 재사용이 가능하도록 작업을 진행하는 것을 말하며 추가/수정/삭제가 쉽다는 특징이 있다. <br/>
객체지향 프로그램이란 프로그램에서 필요한 요소들을 객체로 만들고 이것들을 이용해 프로그래밍 하는 것을 말한다.

- 클래스와 객체
  - 클래스란 하나의 데이터 타입이 되며 틀로서 동작하고 클래스를 통해 실제 생성된 것을 객체라고 한다.
  
cf) 메서드 파라미터로 전달될때 기본형 변수의 경우, 기존의 값이 복사되어 전달되며 참조형 변수의 경우 객체에 대한 참조값이 전달된다.

## 5. 메서드
- 메서드 오버로딩이란 같은 기능을 하는 메서드를 추가하여 파라미터 변수형 등에 따라 다른 메서드가 호출되는 것을 말한다.
- 메서드 오버라이딩이란 조상 클래스에 정의된 기능을 자식 클래스에 적합하게 수정해서 재정의하는 것을 말한다.

## 6. 상속
- 상속은 기존 클래스의 재산을 다른 클래스에서 재사용하기 위한 것이다. UML 에서는 실선의 화살표를 이용하며 하나의 클래스를 여러 클래스가 상속받을 수도 있다.

## 7. 캡슐화
- 캡슐화는 getter 와 setter 를 이용해 데이터를 은닉하고 데이터 검증 로직을 추가함으로써 데이터를 보호할 수 있다.

## 8. 다형성
- 다형성이란 상속 관계에 있을 때 조상 클래스 타입으로 자식 클래스 객체를 레퍼런스 할 수 있는 성질을 말한다. <br/>
다형성을 이용하면 추후에 추가될 참조형 타입 등에 상관없이 동일하게 사용될 수 있게 메소드를 정의하여 재사용성을 높일 수 있다. <br/>
그러나 조상 클래스 타입으로 참조할 경우, 해당 참조한 클래스 타입의 고유 영역만 사용할 수 있으므로 상속된 클래스의 고유한 기능은 사용할 수 없다. <br/>

- 상속 관계에서 객체의 멤버 변수가 중복될 때는 참조 변수의 타입에 따라 연결이 달라진다.
하지만 상속 관계에서 메서드가 오버라이딩 되었을 때는 무조건 자식 클래스의 메서드가 호출된다.

## 9. 인터페이스
- 인터페이스는 사전적으로 두 시스템 간에 만나는 접점이라는 의미가 있다. 자바에서의 인터페이스는 클래스가 아니며 일종의 규칙이라고 볼 수 있다.
 하지만 상속과 다른 점은 구현부가 없기 때문에 복잡도가 올라가지 않으므로 클래스와 다르게 다중 상속이 가능하다는 점이다. 인터페이스가 필요한 이유는 다음과 같다.
  - 구현의 강제로 표준화
  - 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원
  - 상속 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장
  - 모듈 간 독립적 프로그래밍으로 개발 시간 단축
  
=> 다형성 확장이란, 상속 관계가 없는 클래스 간의 특징만을 추출하여 해당 특징 메소드를 지닌 인터페이스를 상속시킨 후 구현은 각 클래스 별로 하여 코드를 간결화 할 수 있다는 것이다.
=> 모듈 간 독립적 프로그래밍이란, 프로젝트를 개발하는 서로 다른 팀 간에 인터페이스 만을 공유하고 개발은 따로 진행하여 동시 개발을 진행함으로써 효율성을 제고할 수 있다는 뜻이다.

- JDK 1.8 부터는 이너페이스에 default 와 static 메서드가 추가되어 인터페이스에 메서드 구현이 가능하고 static 메서드 사용도 가능하다.

## 10. 제네릭
- Object 를 저장할 때와 달리 빼낼 때는 각 오브젝트 타입을 식별할 필요가 있는데, 제네릭은 미리 사용할 수 있는 타입을 명시해서 컴파일 타임에 타입을 체크한다.
따라서, 런타임에 발생하는 ClassCastException 이 발생하지 않는다.
- 제네릭 타입은 클래스 및 인터페이스 이름 뒤에 <> 를 쓰고 타입 파라미터를 명시한다. 이때 타입 파라미터의 관계는 제네릭의 상속 관계와 무관하다.
또한, 사용 가능한 파라미터 타입을 제한하려면 파라미터 타입에 extends 를 적용하면 된다.
- 제네릭 선언은 클래스뿐 아니라 메서드에서도 이뤄질 수 있다. 메서드의 리턴 타입 앞에 타입 파라미터 변수를 서넌하고 리턴 타입 또는 파라미터로 사용할 수 있다.
물론 메서드에 선언된 타입 파라미터의 사용 범위는 해당 메서드로 국한되며 메서드가 호출될 때 확정된다.
- 제네릭 메서드에서는 사용되는 타입 파라미터에 제한을 두기위해 와일드카드로 ? 를 사용한다. 와일드카드는 단독으로 사용될 수 있고 extends 나 super 와 함께 사용될 수 있다.

## 11. 예외처리와 디버깅
- 예외와 관련된 최상위 클래스는 Throwable 이다. 하지만 대부분 이를 상속받은 Exception 이나 Error 가 주로 사용된다.
- RuntimeException 하위 클래스들은 모두 unchecked exception 으로 예외에 대한 처리 코드가 없어도 컴파일 오류가 발생하지 않는다.
- 그 외 나머지 checked exception 의 경우는 예외에 대한 처리 코드가 없을 경우 컴파일 오류가 발생하므로 반드시 작성해야 한다.
- try ~ with ~ resources 구문을 이용하면 try catch 문을 수행한 후 자동으로 close 처리해준다, 
그러나 리소스들은 반드시 AutoCloseable 인터페이스를 구현하고 있어야한다.
- RuntimeException 계열은 try catch 가 없으면 별도의 throws 절이 없어도 예외의 전달이 자동으로 진행된다.
- 상속의 구조 상 조상 클래스 메서드가 예외를 던지고 있고, 자식 클래스에서 그 메서드를 오버라이드 하는 경우 자식의 메서드는 조상 메서드가 던지는 예외보다
부모 예외를 던질 수 없다.
- 사용자 정의 예외 클래스를 사용하면 복잡한 내용을 전달할 수 있다.

  ### 로깅과 디버깅
  - Level.INFO -> Level.WARNING -> Level.SEVERE 단계로 처리된다.
  - addHandler : 과거에 발생한 로그를 장기간 저장하기 위해서는 Handler 를 Logger 에 추가하여 별도의 대상에 출력할 수 있다.
  cf) logback 프레임워크
  
## 12. 내부 클래스와 람다식
- 모듈화를 위해 분리하기는 하지만, has-a 관계에 있는 클래스 내부에서만 사용되는 클래스를 만들 때는 내부 클래스를 고려할 수 있다. 내부 클래스는 중첩 클래스 라고도한다.
- 내부 클래스에서 외부 클래스의 private 을 포함한 모든 멤버에 대해 자유롭게 참조할 수 있다.
- 외부 클래스 멤버를 참조할 때는 외부클래스.this 를 사용한다.

  ### 람다식
  - 람다식이란 자바 8에 추가된 특징으로 자바에서 함수형 프로그래밍 형태를 받아들인 결과이다.
  - 람다식은 런타임에 익명의 내부 클래스로 변경돼서 처리되므로 동작은 동일하다.
  - 따라서 람다식은 결과적으로 인터페이스 타입의 클래스를 손쉽게 구현하는 방법이다.
  - (파라미터) -> {구현부} 의 형태로 작성한다.
  - 파라미터가 하나일 경우, 소괄호를 생략가능하며 실행 문장이 한 문장일 경우 중괄호와 ; 역시 생략한다. (할수있다.)
  - 하지만 파라미터가 하나도 없는 경우는 소괄호를 생략할 수 없다.
  - 람다식 내에서 this 와 외부클래스.this 는 동일한 객체를 나타낸다. (외부 클래스를 나타낸다)
  cf) 함수형 인터페이스 패키지 기본 API
  : Consumer, Supplier, Function, Operation, Predicate 계열

## 13. java.lang 패키지
- System 패키지에서 환경변수 관련 설정을 참고할 수 있다.
- StringBuffer 는 멀티스레드에서 안전하므로 무겁고 StringBuilder 는 반대다.
- Wrapper 클래스에는 Byte, Character, Short, Integer, Long, Float, Double, Boolean 이 있으며 기본형을 객체로 만들기 위한 클래스들이다.
- Wrapper 클래스는 오토박싱과 언박싱을 지원한다.
- StringTokenizer 는 문자열을 구분자 캐릭터를 이용해 분리해주는 클래스이다. 키:값 과 같은 쌍 데이터를 분리할 때 유용하다.
- DecimalFormat 클래스는 숫자에 대한 형식화 클래스이다.
- 정규표현식을 사용하는 클래스로는 Pattern, Matcher 클래스가 있다.

## 14. 컬렉션
- List 계열에는 ArrayList, LinkedList, Stack, Vector 가 있다.
- Set 계열에는 HashSet, TreeSet 이 있다.
- Map 계열에는 HashMap, TreeMap, Hashtable, Properties 가 있다.

## 15. 멀티쓰레드
- 멀티스레드 프로그래밍은 컨텍스트 스위칭 과정에서 싱글스레드에서는 필요 없는 비용이 발생한다.
- 스레드는 일반적으로 Runnable 인터페이스를 구현하는 방법과 Thread 클래스를 상속받는 방법의 두 가지로 만들 수 있다.
- 스레드를 실행할 때는 start() 메서드를 사용하며 이는 JVM 에 스레드 스케줄러에 의해 가능할 때 스레드의 run() 메서드를 호출하도록 요청하는 것과 같다.
- 스레드 상태 값은 Thread 내부에 State 라는 enum 으로 정의되어 있으며 스레드 객체의 getState() 메서드를 이용해서 확인할 수 있다.
- 스레드 우선순위는 setPriority() / getPriority() 메서드로 설정할 수 있다.
- sleep 과 join 은 스레드를 대기 풀로 이동시키는 메서드이다. join 은 다른 스레드와 선후 관계가 있을 때 다른 스레드 작업이 종료될 때까지 대기 풀에서 대기하도록 한다.
- interrupt 를 이용하여 대기 풀에서 탈출하여 RUNNABLE 상태로 이동할 수 있다.
- 스레드 풀 방법을 이용해 생성과 소멸에 드는 비용을 절감할 수 있다.
- 스레드 풀의 경우, ThreadPoolExecutor() 클래스를 사용하여 주로 생성한다.
- 스레드 풀의 경우 처리할 작업은 Runnable 혹은 Callable 타입이며 리턴할 값이 있을 경우 Callable 을 사용하며 call 메서드를 오버라이드 한다.
- 작업처리의 경우 execute 혹은 submit 을 사용하며 submit 은 작업 결과인 Future 클래스를 리턴한다.

## 16. I/O 와 스트림
- 스레드 간의 통신을 위해서는 PipedInputStream/PipedOutputStream (or Reader/Writer) 이 사용된다.
- 스레드 스트림의 경우 사용전 connect() 메서드를 이용해서 서로 연결해줘야 하며 한쪽 스트림을 종료시키면 다른쪽 스트림은 자동으로 종료된다.
- 노드에 직접 연결되지 않도 다른 스트림과 연결되는 스트림을 보조 스트림이라고 한다. 따라서, 필터 혹은 프로세싱 스트림이라고도 부른다.
- 보조 스트림을 close 하면 노드 스트림까지 알아서 close 처리된다.
- 버퍼 스트림을 이용하면 하드디스크 자료를 직접 읽는 것보다 일단 메모리에 올린 후 처리하므로 효율적이다.
- 객체 저장을 위한 Object Stream 의 경우, 객체가 가진 데이터 즉 멤버 변수들을 전송하기 이해 연속적인 데이터 형태로 변환하는 객체 직렬화 과정이  필요하다. (읽는 경우 역직렬화 필요)
- Serializable 인터페이스를 상속받아서 하되, 민감한 정보는 transient 키워드를 사용하여 직렬화에서 제외한다.
- 직렬화 가능한 클래스에는 serialVersionUID 멤버 변수를 추가하여 클래스 변경 여부를 파악하는 것이 좋다. (버전이 달라지면 역직렬화 시 문제가 생길 수 있다.)
- 역직렬화 과정에서 클래스 버전 확인에 사용되는 것이 serialVerionUID 인데 이것이 맞지 않으면 InvalidClassException 이 발생한다.
- serialVersionUID 를 설정하지 않을 경우, 컴파일 시마다 컴파일러가 이를 변경시키므로 설정하는 것을 권장한다.
- 조상클래스가 직렬화 되지 않았을 경우, 상속받은 클래스에서 조상의 멤버변수를 먼저 직렬화하고 읽을 때도 순서를 그대로 따라야한다.
- NIO 는 JDK 1.4 에 처음 등장했으며 양방향 입출력을 사용하며 버퍼를 기본으로 제공, 블로킹과 넌-블로킹을 모두 지원한다.
- 따라서 NIO 는 여러 클라이언트 연결을 넌-블로킹으로 처리하고 짧은 입출력 작업에 적합하다.
